<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Методы JS</title>
  <link type="image/x-icon" href="img/favicon-js.svg" rel="shortcut icon">
  <link type="font/woff" href="fonts/Exo20-Light.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-ExtraLight.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-Medium.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-Regular.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-Bold.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-SemiBold.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-ExtraBold.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-Black.woff" rel="preload" as="font" crossorigin>
  <link type="font/woff" href="fonts/Exo20-Thin.woff" rel="preload" as="font" crossorigin>
  <link href="css/styles.css" rel="stylesheet">
  <script src="js/app.js" defer></script>
</head>

<body>
  <div id="wrapper" class="wrapper">
    <header id="header" class="header">
      <div class="header__container">
        <nav class="header__top header-top-nav">
          <ul class="header-top-nav__menu header-menu list">
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link header-menu-item__link--main-page link" href="index.html">
                <span>ГЛАВНАЯ</span>
              </a>
            </li>
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link link" href="html-css.html">
                <span>HTML&CSS</span>
                <svg viewBox="0 0 12 7" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M11 1L6 6.00001L0.999997 1" stroke="black"></path>
                </svg>
              </a>
              <ul class="header-menu-item__submenu header-submenu list">
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>HTML-1</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>HTML-2</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>CSS</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>SCSS</span>
                  </a>
                </li>
              </ul>
            </li>
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link link" href="js.html">
                <span>JavaScript</span>
                <svg viewBox="0 0 12 7" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M11 1L6 6.00001L0.999997 1" stroke="black"></path>
                </svg>
              </a>
              <ul class="header-menu-item__submenu header-submenu list">
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Типы данных</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="js-operators.html">
                    <span>Операторы</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Циклы</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Функции</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Объекты</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="js-methods.html">
                    <span>Методы</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>События DOM</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>JSON (JavaScript Object Notation)</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link header-menu-item__link--git link" href="#">
                    <span>Справочник JavaScript</span>
                  </a>
                </li>
              </ul>
            </li>
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link header-menu-item__link--git link" href="git.html">
                <span>Git</span>
              </a>
            </li>
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link link" href="tools.html">
                <span>Инструменты</span>
                <svg viewBox="0 0 12 7" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M11 1L6 6.00001L0.999997 1" stroke="black"></path>
                </svg>
              </a>
              <ul class="header-menu-item__submenu header-submenu list">
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>SWIPER (слайдер)</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
              </ul>
            </li>
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link link" href="templates.html">
                <span>Шаблоны</span>
                <svg viewBox="0 0 12 7" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M11 1L6 6.00001L0.999997 1" stroke="black"></path>
                </svg>
              </a>
              <ul class="header-menu-item__submenu header-submenu list">
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Todo-list</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>counter-reset(пример счётчика)</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Форма</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>FlexBox</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Адаптивный слайдер на JS</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>SliderCar</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Пример шапки</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Pop-up (модальное окно)</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Tabs (табы)</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Аккордион</span>
                  </a>
                </li>
              </ul>
            </li>
            <li class="header-menu__item header-menu-item">
              <a class="header-menu-item__link link" href="guide.html">
                <span>Справочник</span>
                <svg viewBox="0 0 12 7" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M11 1L6 6.00001L0.999997 1" stroke="black"></path>
                </svg>
              </a>
              <ul class="header-menu-item__submenu header-submenu list">
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
                <li class="header-submenu__item header-submenu-item">
                  <a class="header-submenu-item__link link" href="#">
                    <span>Link</span>
                  </a>
                </li>
              </ul>
            </li>
          </ul>
        </nav>
        <div class="header__other header-other">
          <a class="header-other__logo header-logo link" href="#">
            <span>SSR</span>
          </a>
          <form class="header-other__search-form header-search-form" action="#" method="post">
            <input class="header-search-form__input input" type="text" placeholder="Поиск по сайту" required>
            <button class="header-search-form__btn btn" type="button" aria-label="Найти" title="Поиск">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="32px" height="32px" fill="#fff">
                <path d="M 21 3 C 11.621094 3 4 10.621094 4 20 C 4 29.378906 11.621094 37 21 37 C 24.710938 37 28.140625 35.804688 30.9375 33.78125 L 44.09375 46.90625 L 46.90625 44.09375 L 33.90625 31.0625 C 36.460938 28.085938 38 24.222656 38 20 C 38 10.621094 30.378906 3 21 3 Z M 21 5 C 29.296875 5 36 11.703125 36 20 C 36 28.296875 29.296875 35 21 35 C 12.703125 35 6 28.296875 6 20 C 6 11.703125 12.703125 5 21 5 Z" />
              </svg>
            </button>
          </form>
          <button class="header-other__burger header-burger btn">
            <span></span>
          </button>
        </div>
      </div>
    </header>
    <main id="main" class="main">
      <section id="js-hero" class="hero">
        <div class="hero__container">
          <h1 class="hero__title title">Методы</h1>
          <div class="hero__btns">
            <button class="hero__burger btn">
              <span></span>
            </button>
            <button class="theme-btn btn">
              <span></span>
            </button>
          </div>
          <nav class="hero__nav">
            <ul class="hero__menu hero-menu list">
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#fill" title="заполнение массива">
                  <span>Метод fill()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#sort" title="сортировка значений">
                  <span>Метод sort()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#filter" title="фильтрация значений">
                  <span>Метод filter()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#includes" title="проверка наличия значения">
                  <span>Метод includes()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#trim" title="удаление пробелов">
                  <span>Метод trim()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#replace" title="замена всех или первого вхождения подстроки">
                  <span>Метод replace()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#replace-all" title="замена всех вхождений строки">
                  <span>Метод replaceAll()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#shift" title="удаление первого элемента, удаление последнего элемента">
                  <span>Методы shift() и pop()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#unshift" title="добавление элемента(ов) в начало массива, добавление элемента(ов) в конец массива">
                  <span>Методы unshift() и push()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#splice" title="удаление/замена/добавление элементов в определённые позиции">
                  <span>Метод splice()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#indexof" title="определение индекса по значению">
                  <span>Метод indexOf()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#split" title="Разделение/соединение строк">
                  <span>Методы split() и join()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#map" title="выведение значений в определённых условиях">
                  <span>Метод map()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#flat" title="Разглажвание/сплющивание массивов">
                  <span>Методы flat() и flatMap()</span>
                </a>
              </li>
              <li class="hero-menu__item">
                <a class="hero-menu__link link js-scroll-link" href="#" title="#">
                  <span></span>
                </a>
              </li>
            </ul>
          </nav>
        </div>
      </section>
      <section id="fill" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Метод fill()</h2>
          <div class="section__block section-block">
            <p class="section-block__text text">
              Метод <span class="span-text">fill()</span> - это метод массивов в JavaScript, который позволяет заполнить все элементы массива одним и тем же значением.
            </p>
            <p class="section-block__text text">
              Синтаксис метода <span class="span-text">fill()</span> выглядит следующим образом:
            </p>
            <pre class="section-block__pre pre">
arr.fill(value, start, end);
            </pre>
            <dl>
              <dd><span class="span-text">value</span> - значение, которым заполняются все элементы массива.</dd><br>
              <dd><span class="span-text">start</span> (необязательный параметр) - индекс, с которого начинается заполнение. По умолчанию равен 0. <span title="Положительное число - это индекс после которого идёт заполнение. Отрицательное число указывает сколько значений заполнить с конца массива." class="js-methods-tooltip">!</span></dd><br>
              <dd><span class="span-text">end</span> (необязательный параметр) - индекс, до которого происходит заполнение. По умолчанию равен длине массива. УМетод не включает этот элемент в заполнение. <span title="Отрицательное число отсчёт с конца массива, после которого идёт заполнение." class="js-methods-tooltip">!</span></dd>
            </dl>
            <p class="section-block__text text">
              Примеры использования метода fill():
            </p>
            <pre class="section-block__pre pre">
let arr = [1, 2, 3, 4, 5];
arr.fill(0); <span class="com">// [0, 0, 0, 0, 0]</span>

let arr2 = [1, 2, 3, 4, 5];
arr2.fill(0, 2, 4); <span class="com">// [1, 2, 0, 0, 5]</span>
            </pre>
            <p class="section-block__text text">
              В первом примере все элементы массива arr заполняются нулями. Во втором примере только элементы с индексами от 2 до 4 заполняются нулями, а остальные остаются без изменений.
            </p>
            <p class="section-block__text text">
              Метод <span class="span-text">fill()</span> также поддерживается в массивоподобных объектах, таких как строка (тип String) или псевдомассив аргументов функции (тип arguments).
            </p>
            <pre class="section-block__pre pre">
const array = new Array(5).fill('oppo', 2, -2);

console.log(array); <span class="com">// [,,'oppo',,]</span>
            </pre>
          </div>
        </div>
      </section>
      <section id="sort" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Метод sort()</h2>
          <div class="section__block section-block">
            <p class="section-block__text text">
              <span class="span-text">sort()</span> &mdash; при сортировке изменяет изначальный массив, поэтому необходимо создать копию массива, который будет сортироваться.
            </p>
            <a class="section-block__link" href="https://jsbin.com/zukozik/edit?js,console" target="_blank">
              Ссылка на способы дублирования массива.
            </a>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item">
                <p class="section-block__text text">
                  <span class="span-text">sort()</span> &mdash;&nbsp;без заданных параметров сортирует как строки посимвольно.
                </p>
                <pre class="section-block__pre pre">
const numbs = [9,5,8,2,45,6,7,1542,3];

console.log(numbs.sort()); <span class="com">// [1542,2,3,45,5,6,7,8,9]</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text"><b>Сортировка чисел</b></p>
                <p class="section-block__text text">
                  Для сортировки чисел необходимо задать параметры и&nbsp;создать функцию.
                </p>
                <p class="section-block__text text">
                  #1
                </p>
                <pre class="section-block__pre pre">
const numbs = [9,5,8,2,4,6,7,1,3];

const arrNumbs = numbs.slice(); <span class="com">// дублирует массив</span>

arrNumbs.sort((a, b) =&gt; a - b); <span class="com">// b – a сортирует в обратном порядке</span>

console.log(arrNumbs); <span class="com">// [1,2,3,4,5,6,7,8,9]</span>

<span class="com">
// длинный вариант

// arrNumbs.sort((a, b) =&gt; {
//   return a - b; // return указать обязательно
// });
</span>
                </pre>
                <p class="section-block__text text">
                  #2
                </p>
                <pre class="section-block__pre pre">
const numbs = [9,5,8,2,4,6,7,1,3];

const arrNumbs = [...numbs]; <span class="com">// дублирует массив</span>

arrNumbs.sort((a, b) =&gt; {
  if (a &gt; b) return -1; <span class="com">// a &lt; b сортирует в обратном порядке</span>
});

console.log(arrNumbs); <span class="com">// [9,8,7,6,5,4,3,2,1]</span>
<span class="com">
// длинный вариант

// arrNumbs.sort((a, b) =&gt; {
//   if (a &gt; b) {
//     return 1;
//   } else {
//     return -1;
//   }
// });
</span>
                </pre>
                <a class="section-block__link" href="https://codepen.io/archicolt/pen/qBJWeLN?editors=0012" target="_blank">Ссылка на простые примеры сортировки</a>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text"><b>Сортировка строк</b></p>
                <p class="section-block__text text">
                  <span class="span-text">localeCompare()</span> - этот метод помогает сортировать строки.
                </p>
                <pre class="section-block__pre pre">
let arr = [
  {name: "John", age: 74},
  {name: "Alex", age: 6},
  {name: "Anna", age: 28},
  {name: "Kate", age: 17},
  {name: "Ivan", age: 32},
  {name: "Petro", age: 41}
];

const array = [...arr].sort((a, b) =&gt; {
  return a.name<span class="span-text">.localeCompare</span>(b.name);
});

console.log(array);
<span class="com">
// [
//  {"name": "Alex", "age": 6},
//  {"name": "Anna", "age": 28},
//  {"name": "Ivan", "age": 32},
//  {"name": "John", "age": 74},
//  {"name": "Kate", "age": 17},
//  {"name": "Petro", "age": 41}
// ]
</span>
                </pre>
                <p class="section-block__text text">
                  Важно помнить, что метод <span class="span-text">sort()</span> может работать неправильно с некоторыми локализациями.
                </p>
                <p class="section-block__text text">
                  Например, в некоторых языках сортировка должна производиться по алфавиту не в лексикографическом порядке (a-b-c-...), а в соответствии с локализованными правилами (гласные, согласные, и т.д.).
                </p>
                <p class="section-block__text text">
                  Для таких случаев рекомендуется использовать метод <span class="span-text">localeCompare()</span>, который обеспечивает правильную локализованную сортировку строк.
                </p>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  <b>Фича для сортировки на разных языках</b>
                </p>
                <p class="section-block__text text">
                  <span class="span-text">new Intl.Collator()</span> - (Intl - internationalization) метод для правильного сортирования в алфавитном порядке на любых языках.
                </p>
                <p class="section-block__text text">
                  Также включает в себя поддержку нестандартных символов и чувствительность к регистру. Кроме того, этот метод производительнее и более надёжен в работе.
                </p>
                <pre class="section-block__pre pre">
<span class="span-text">const collatore = new Intl.Collator("ru-RU");</span>
const users = [
  {name: "Алексей", age: 26},
  {name: "Степан", age: 19},
  {name: "Екатерина", age: 22},
  {name: "Тимофей", age: 27,},
  {name: "Оксана", age: 25,},
  {name: "Тимур", age: 29,},
  {name: "Светлана", age: 21,},
]

users.sort((a, b) =&gt; <span class="span-text">collatore.compare</span>(a.name, b.name));

console.log(users);
<span class="com">
  [
    {"name": "Алексей", "age": 26},
    {"name": "Екатерина", "age": 22},
    {"name": "Оксана", "age": 25},
    {"name": "Светлана", "age": 21},
    {"name": "Степан", "age": 19},
    {"name": "Тимофей", "age": 27},
    {"name": "Тимур", "age": 29}
  ]
</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  <b>Назначение и удаление определённых значений</b>
                </p>
                <pre class="section-block__pre pre">
const a = [1,2,3,4,5];

const b = [...a];

b[7] = 2.5;

b[9] = 9.8;

delete b[7];

const c = b.slice().sort((a, b) =&gt; {
  return a - b;
});

console.log(c); <span class="com">// [1,2,3,4,5,9.8,,,,]</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  <b>Более сложный вариант сортировки от MaxGraph</b>
                </p>
                <pre class="section-block__pre pre">
let arr = [
  {name: "John", age: 74},
  {name: "Alex", age: 6},
  {name: "Anna", age: 28},
  {name: "Kate", age: 17},
  {name: "Ivan", age: 32},
  {name: "Petro", age: 41}
];

<span class="com">
// function sortUsers(arr, prop, dir = false) {
// let result = arr.sort(function (a, b) {
//   if (!dir ? a[prop] &lt; b[prop] : a[prop] &gt; b[prop]) return -1;
//   let dirIf = a[prop] &lt; b[prop];
//   if (dir == true) dirIf = a[prop] &gt; b[prop];
//   if (dirIf == true) {
//     return -1;
//   }
// });
// return result;
// }
</span>

<span class="com">// сокращённый вариант</span>
const sortUsers = (arr, prop, dir = false) =&gt;
  arr.sort((a, b) =&gt; ((!dir ? a[prop] &lt; b[prop] : a[prop] &gt; b[prop]) ? -1 : 1));

<span class="com">// при выборе определённого списка сортировки задаётся параметр переменной dir = false или true</span>
console.log(sortUsers(arr, "name", true));
                </pre>
              </li>
            </ol>
          </div>
        </div>
      </section>
      <section id="filter" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Метод filter()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <p class="section-block__text text">
              Метод <span class="span-text">filter()</span> в JavaScript позволяет фильтровать элементы массива и возвращать только те элементы, которые соответствуют заданному условию. Он принимает на вход callback-функцию, которая задает условие для фильтрации элементов массива.
            </p>
            <p class="section-block__text text">
              Функция <span class="span-text">filter()</span> не изменяет оригинальный массив, а возвращает новый массив, содержащий отфильтрованные элементы.
            </p>
            <p class="section-block__text text">
              Синтаксис метода <span class="span-text">filter()</span> выглядит следующим образом:
            </p>
            <pre class="section-block__pre pre">
const newArray = array.filter((currentValue, index, arr) =&gt; {
  <span class="com">// тело функции</span>
});
            </pre>
            <ul class="section-block__list">
              где:
              <li class="section-block__item">
                <span class="span-text">array</span> - исходный массив;
              </li>
              <li class="section-block__item">
                <span class="span-text">currentValue</span> - текущий элемент массива;
              </li>
              <li class="section-block__item">
                <span class="span-text">index (опциональный)</span> - индекс текущего элемента массива;
              </li>
              <li class="section-block__item">
                <span class="span-text">arr (опциональный)</span> - ссылка на исходный массив;
              </li>
              <li class="section-block__item">
                <span class="span-text">newArray</span> - новый массив, содержащий отфильтрованные элементы;
              </li>
              <li class="section-block__item">
                <span class="span-text">callback</span> - функция, которая задает условие для отбора элементов.
              </li>
            </ul>
            <p class="section-block__text text">Примеры использования метода <span class="span-text">filter()</span>:</p>
            <pre class="section-block__pre pre">
const a = [3, 5, 81, 3984, 7, 3, 85, 98, 6, 27, 95];

let b = a.filter((item) <span class="com">/* параметр */</span> =&gt; {
  if (item &lt;= 81) return true; <span class="com">// необходимо указывать true, чтобы не выпал false</span>
});
console.log(b); <span class="com">// [81,3984,85,98,95]</span>
            </pre>
          </div>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre">
const clients = [
  { lin: "s2d1fs65g", user: "Smith", debt: 4 },
  { lin: "3d5fg4sdg", user: "Ftith", debt: 0 },
  { lin: "df5g4d3bd", user: "Dmyth", debt: 0 },
  { lin: "b6dfb335b", user: "Pmuth", debt: 0 },
  { lin: "3df5b4df3", user: "Rmeth", debt: 42435 },
  { lin: "6db5d99fb", user: "Math", debt: 1684 },
  { lin: "645d6b4d6", user: "Hmoth", debt: 2654 }
];


<span class="com">// короткий вариант</span>
let debts = clients
  .filter((item) =&gt; item.debt &gt;= 1500) <span class="com">// выбрать должников</span>
  .sort((a, b) =&gt; b.user - a.user); <span class="com">// сортировка выбранных должников</span>
console.log(debts);

<span class="com">// длинный вариант</span>
let debts = debtors.filter(function(item){
  return item.debt >= 1500;
}).sort(function(a, b){
  return new Intl.Collator("ru-RU").compare(a.user, b.user);
});
<span class="com">// new Intl.Collator("ru-RU") - сортировка по русскому алфавиту</span>

<span class="com">
[
  {"lin": "645d6b4d6", "user": "Hmoth", "debt": 2654},
  {"lin": "6db5d99fb", "user": "Math", "debt": 1684},
  {"lin": "3df5b4df3", "user": "Rmeth", "debt": 42435}
]
</span>
            </pre>
          </div>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre">
const names = ["Oleg", "Anna", "Alexander"];

const namesChange = names.filter(function (name) {
  return name.length &lt; 5;
});

console.log(namesChange); <span class="com">// ['Oleg','Anna']</span>
            </pre>
          </div>
        </div>
      </section>      
      <section id="includes" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Метод includes()</h2>
          <div class="section__block section-block">
            <p class="section-block__text text">
              Метод <span class="span-text">includes()</span> в JavaScript используется для определения, содержит ли массив или строка определенное значение, и возвращает булево значение true или false.
            </p>
            <br>
            <p class="section-block__text text">
              <b>Синтаксис метода для массива:</b>
            </p>
            <pre class="section-block__pre pre">
arr.includes(valueToFind, fromIndex)
            </pre>
            <ul class="section-block__list">
              где:
              <li class="section-block__item">
                <span class="span-text">valueToFind</span> - значение, которое нужно найти в массиве;
              </li>
              <li class="section-block__item">
                <span class="span-text">fromIndex (необязательный параметр)</span> - индекс, начиная с которого нужно начать поиск.
              </li>
            </ul>
            <p class="section-block__text text">
              Если <span class="span-text">fromIndex</span> не указан, поиск начинается с 0.
            </p>
            <p class="section-block__text text">
              Если <span class="span-text">fromIndex</span> отрицательное число, поиск будет производиться с конца массива.
            </p>
            <br>
            <p class="section-block__text text">
              <b>Синтаксис метода для строк:</b>
            </p>
            <pre class="section-block__pre pre">
str.includes(searchString, position)
            </pre>
            <ul class="section-block__list">
              где:
              <li class="section-block__item">
                <span class="span-text">searchString</span> - строка, которую нужно найти в другой строке;
              </li>
              <li class="section-block__item">
                <span class="span-text">position (необязательный параметр)</span> - позиция в строке, начиная с которой нужно начать поиск.
              </li>
            </ul>
            <p class="section-block__text text">
              Если <span class="span-text">position</span> не указан, поиск начинается с 0.
            </p>
            <br>
            <p class="section-block__text text">
              Пример использования метода <span class="span-text">includes()</span> для массива:
            </p>
            <pre class="section-block__pre pre">
const arr = [1, 2, 3, 4, 5];
console.log(arr.includes(3)); <span class="com">// true</span>
console.log(arr.includes(6)); <span class="com">// false</span>
console.log(arr.includes(2, 2)); <span class="com">// false</span>
console.log(arr.includes(2, -3)); <span class="com">// true</span>
            </pre>
            <pre class="section-block__pre pre">
const users = [
  { name: "алексей", age: 26 },
  { name: "степан", age: 19 },
  { name: "екатерина", age: 22 },
  { name: "тимофей", age: 27 },
  { name: "оксана", age: 25 },
  { name: "тимур", age: 29 },
  { name: "светлана", age: 21 }
];

const newUsers = users.filter((value) =&gt; {
  return value.name.includes("ти");
});

console.log(newUsers);
<span class="com">
[
  {"name": "тимофей", "age": 27},
  {"name": "тимур", "age": 29}
]
</span>
            </pre>
            <br>
            <p class="section-block__text text">
              Пример использования метода <span class="span-text">includes()</span> для строки:
            </p>
            <pre class="section-block__pre pre">
const str = "Hello, World!";
console.log(str.includes("l")); <span class="com">// true</span>
console.log(str.includes("Wor")); <span class="com">// true</span>
console.log(str.includes("wor")); <span class="com">// false</span>
console.log(str.includes("l", 3)); <span class="com">// true</span>
            </pre>
            <hr>
            <p class="section-block__text text">
              <strong>Функция эмулированная под метод includes()</strong>
            </p>
            <p class="section-block__text text">HTML</p>
            <pre class="section-block__pre pre">
&lt;input type="text" placeholder="Введите число"&gt;

&lt;button type="button" style="cursor: pointer;" class="btn"&gt;BUTTON&lt;/button&gt;

&lt;p class="value"&gt;&lt;/p&gt;
            </pre>
            <p class="section-block__text text">JS</p>
            <pre class="section-block__pre pre">
const btn = document.querySelector(".btn");

function funcIncludes() {
  const numbs = [87, 35, 46, 91, 32];
  <span class="com">// значение инпута</span>
  let inputValue = +document.querySelector("input").value;
  let res = false;

  <span class="com">// перебор и сравнение значения массива со значением инпута</span>
  for (let i = 0; i &gt; numbs.length; i++) {
    if (inputValue == numbs[i]) {
      res = true;
      break;
    }
  }
  <span class="com">// вывод результата функции</span>
  document.querySelector(".value").innerHTML = res;
}

btn.addEventListener("click", (e) =&lt; {
  e.preventDefault();
  funcIncludes();
  inputValue = "";
});
            </pre>
          </div>
        </div>
      </section>
      <section id="trim" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Метод trim()</h2>
          <div class="section__block section-block">
            <p class="section-block__text text">
              Метод <span class="span-text">trim()</span> удаляет пробелы в начале и в конце строки.
            </p>
            <pre class="section-block__pre pre">
const str = <span class="span-text">'   some text     '</span>;

console.log(str.trim()); <span class="com">// some text</span>
            </pre>
            <p class="section-block__text text">
              Он возвращает новую строку, в которой все пробелы в начале и конце исходной строки удалены. При этом исходная строка остается неизменной.
            </p>
            <p class="section-block__text text">
              Пример использования метода <span class="span-text">trim()</span>:
            </p>
            <pre class="section-block__pre pre">
let str = "   Привет, мир!   ";
let trimmedStr = str.trim();

console.log(trimmedStr); <span class="com">// "Привет, мир!"</span>
            </pre>
            <p class="section-block__text text">
              В данном примере метод <span class="span-text">trim()</span> удаляет все пробелы, находящиеся в начале и конце строки " Привет, мир! ", возвращая новую строку "Привет, мир!".
            </p>
            <p class="section-block__text text">
              Метод <span class="span-text">trim()</span> полезен, когда необходимо удалить лишние пробелы в значении, введенном пользователем, или при сравнении строк, когда пробелы в начале и конце не играют роли, но могут повлиять на результат сравнения.
            </p>
            <p class="section-block__text text">
              Также существуют вариации метода <span class="span-text">trim()</span>, такие как <span class="span-text">trimStart()</span> (для удаления пробелов в начале строки) и <span class="span-text">trimEnd()</span> (для удаления пробелов в конце строки), введенные с выпуском стандарта ECMAScript 2019 (ES10). Эти методы могут быть полезны в случаях, когда требуется удалить пробелы только в определенной части строки.
            </p>
          </div>
        </div>
      </section>
      <section id="replace" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Метод replace()</h2>
          <div class="section__block section-block">
            <hr>
            <p class="section-block__text text">
              С помощью метода <span class="span-text">replace()</span> возможно удалить все пробелы в строке, передав ему первым аргументом <span class="span-text">/\\s/g</span>, а вторым пустую строку <span class="span-text">""</span>.
            </p>
            <pre class="section-block__pre pre">
const text = <span class="span-text">'   Это текст, из которого мы хотим удалить      все пробелы .     '</span>;

console.log(text.replace(/\\s/g, '')); <span class="com">// Этотекст,изкоторогомыхотимудалитьвсепробелы.</span>
            </pre>
            <hr>
            <br><br><br>
            <p class="section-block__text text">
              Метод <span class="span-text">replace()</span> в JavaScript используется для замены всех или первого вхождения подстроки в строке на другую подстроку.
            </p>
            <p class="section-block__text text">
              Синтаксис метода:
            </p>
            <pre class="section-block__pre pre">
string.replace(searchValue, replaceValue)
            </pre>
            <ul class="section-block__list">
              <li class="section-block__item">
                <span class="span-text">searchValue</span>: это строка или регулярное выражение, которое нужно найти и заменить в исходной строке.
              </li>
              <li class="section-block__item">
                <span class="span-text">replaceValue</span>: это строка, которой нужно заменить найденное значение
              </li>
            </ul>
            <p class="section-block__text text">
              Метод <span class="span-text">replace()</span> возвращает новую строку, в которой все вхождения <span class="span-text">searchValue</span> заменены на <span class="span-text">replaceValue</span>. Обратите внимание, что метод <span class="span-text">replace()</span> не изменяет оригинальную строку, а возвращает новую строку, на которую можно ссылаться.
            </p>
            <p class="section-block__text text">
              Параметр <span class="span-text">searchValue</span> может быть как строкой, так и регулярным выражением. Если <span class="span-text">searchValue</span> является строкой, то метод заменяет только первое вхождение строки в исходной строке. Если <span class="span-text">searchValue</span> является регулярным выражением с флагом g (глобальный поиск), то метод заменяет все вхождения регулярного выражения в исходной строке.
            </p>
            <p class="section-block__text text">
              Если параметр <span class="span-text">replaceValue</span> является строкой, то метод заменяет искомое значение на эту строку. Дополнительно, внутри строки <span class="span-text">replaceValue</span> можно использовать специальные символы, такие как $1, $2, которые будут заменены на соответствующие найденные группы в регулярном выражении.
            </p>
            <p class="section-block__text text">
              Кроме того, вместо строки <span class="span-text">replaceValue</span>, можно передать функцию обратного вызова <span class="span-text">(callback function)</span>. Тогда эта функция будет вызываться для каждого найденного значения, и ей будет передано найденное значение. Затем, значение, возвращенное функцией, будет использовано в качестве замены. Это позволяет осуществлять более сложные преобразования строк.
            </p>
            <p class="section-block__text text">
              Вот несколько примеров использования метода <span class="span-text">replace()</span>:
            </p>
            <pre class="section-block__pre pre">
const str = 'Hello world!';
const newStr = str.replace('world', 'John');

console.log(newStr); <span class="com">// Hello John!</span>
            </pre>
            <p class="section-block__text text">
              В первом примере заменяем слово 'world' на 'John'.
            </p>
            <pre class="section-block__pre pre">
const str2 = 'Hello world, world!';
const newStr2 = str2.replace(/world/g, 'John');

console.log(newStr2); <span class="com">// Hello John, John!</span>
            </pre>
            <p class="section-block__text text">
              Во втором примере делаем то же самое, но с использованием регулярного выражения и флага g (глобального поиска).
            </p>
            <pre class="section-block__pre pre">
const str3 = '1 apple, 2 bananas, 3 cucumbers';
const newStr3 = str3.replace(/\d+ (\w+)/g, function(match, capturedGroup) {
  return capturedGroup.toUpperCase();
});

console.log(newStr3); <span class="com">// 1 APPLE, 2 BANANAS, 3 CUCUMBERS</span>
            </pre>
            <p class="section-block__text text">
              В третьем примере заменяем все вхождения строки вида "число слово" на прописное слово при помощи функции обратного вызова.
            </p>
          </div>
        </div>
      </section>
      <section id="replace-all" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Метод replaceAll()</h2>
          <div class="section__block section-block">
            <hr>
            <p class="section-block__text text">
              С помощью метода <span class="span-text">replaceAll()</span> возможно удалить все пробелы в строке, передав ему первым аргументом пробел <span class="span-text">" "</span>, а вторым пустую строку <span class="span-text">""</span>.
            </p>
            <pre class="section-block__pre pre">
const text = <span class="span-text">'   Это текст, из которого мы хотим удалить      все пробелы .     '</span>;

console.log(text.replaceAll(' ', '')); <span class="com">// Этотекст,изкоторогомыхотимудалитьвсепробелы.</span>
            </pre>
            <hr>
            <br><br><br>
            <p class="section-block__text text">
              Метод <span class="span-text">replaceAll()</span> в JavaScript используется для замены всех вхождений строки на другую строку. Он работает с помощью регулярного выражения, что позволяет заменять все соответствующие шаблону совпадения.
            </p>
            <p class="section-block__text text">
              Синтаксис метода:
            </p>
            <pre class="section-block__pre pre">
string.replaceAll(searchValue, replaceValue)
            </pre>
            <ul class="section-block__list">
              <li class="section-block__item">
                <span class="span-text">searchValue</span> - строка или регулярное выражение, которое нужно найти и заменить.
              </li>
              <li class="section-block__item">
                <span class="span-text">replaceValue</span> - строка, которой заменяют найденные совпадения.
              </li>
            </ul>
            <p class="section-block__text text">
              Например, чтобы заменить все пробелы в строке на дефисы, можно использовать следующий код:
            </p>
            <pre class="section-block__pre pre">
let str = "Привет мир";
let newStr = str.replaceAll(" ", "-");

console.log(newStr); <span class="com">// Вывод: "Привет-мир"</span>
            </pre>
            <p class="section-block__text text">
              Метод <span class="span-text">replaceAll()</span> заменяет все пробелы на дефисы и создает новую строку, которая сохраняется в переменной <span class="span-text">newStr</span>.
            </p>
            <p class="section-block__text text">
              Также, метод <span class="span-text">replaceAll()</span> может принимать регулярное выражение:
            </p>
            <pre class="section-block__pre pre">
let str = "Метод replaceAll() заменяет. replaceAll регистрозависимый.";
let newStr = str.replaceAll(/replaceAll/gi, "заменяет");

console.log(newStr);
<span class="com">// Вывод: "Метод заменяет() заменяет. заменяет регистрозависимый."</span>
            </pre>
            <p class="section-block__text text">
              Важно отметить, что метод <span class="span-text">replaceAll()</span> возвращает новую строку, а не изменяет исходную. Поэтому рекомендуется сохранять результат в новой переменной.
            </p>
          </div>
        </div>
      </section>
      <section id="shift" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Методы shift() и pop()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title">Метод shift()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">shift()</span> в JavaScript используется для удаления первого элемента из массива и возвращения его значения.
            </p>
            <p class="section-block__text text">
              При этом все остальные элементы массива сдвигаются на одну позицию влево, каждый элемент занимает место своего предшественника.
            </p>
            <p class="section-block__text text">
              Синтаксис метода:
            </p>
            <pre class="section-block__pre pre">
array.shift()
            </pre>
            <p class="section-block__text text">
              Метод не принимает параметров.
            </p>
            <p class="section-block__text text">
              Он может быть вызван только для объекта-массива, для которого был вызван. Если массив пустой, метод возвращает значение undefined.
            </p>
            <p class="section-block__text text">Пример:</p>
            <pre class="section-block__pre pre">
var arr = [1, 2, 3, 4];
var firstElement = arr.shift(); <span class="com">// удаляем первый элемент массива и сохраняем его значение в переменную</span>
console.log(firstElement); // 1
console.log(arr); <span class="com">// [2, 3, 4]</span>
            </pre>
            <p class="section-block__text text">
              В этом примере мы создали массив [1, 2, 3, 4], затем вызвали метод shift() для этого массива.
            </p>
            <p class="section-block__text text">
              Этот метод удалил первый элемент (1) и вернул его значение, которое мы сохранили в переменную firstElement.
            </p>
            <p class="section-block__text text">
              Затем мы вывели значение первого элемента и массив без первого элемента.
            </p>
          </div>
          <div class="section__block section-block">
            <h3 class="section-block__title title">Метод pop()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">pop()</span> в JavaScript используется для удаления последнего элемента из массива и возвращает удаленный элемент.
            </p>
            <p class="section-block__text text">
              Он изменяет исходный массив, удаляя последний элемент из него.
            </p>
            <p class="section-block__text text">Синтаксис метода:</p>
            <pre class="section-block__pre pre">
array.pop()
            </pre>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre">
const array = [1, 2, 3, 4, 5];
const lastElement = array.pop();
console.log(lastElement); <span class="com">// Выведет 5</span>
console.log(array); <span class="com">// Выведет [1, 2, 3, 4]</span>
            </pre>
            <p class="section-block__text text">
              В данном примере метод <span class="span-text">pop()</span> удаляет последний элемент 5 из массива array и возвращает его значение. Затем последний элемент выводится на консоль. После выполнения метода массив array становится равен [1, 2, 3, 4].
            </p>
            <p class="section-block__text text">
              Метод <span class="span-text">pop()</span> является обратной операцией для метода <span class="span-text">push()</span>, который добавляет элемент в конец массива. Оба метода можно комбинировать для управления элементами массива в его конце.
            </p>
          </div>
        </div>
      </section>
      <section id="unshift" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Методы unshift() и push()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title">
              Метод unshift()
            </h3>
            <p class="section-block__text text">
              Метод <span class="span-text">unshift()</span> в JavaScript используется для добавления одного или нескольких элементов в начало массива.
            </p>
            <p class="section-block__text text">
              Он изменяет исходный массив и возвращает новую длину массива.
            </p>
            <p class="section-block__text text">
              Синтаксис метода:
            </p>
            <pre class="section-block__pre pre">
array.unshift(item1, item2, ..., itemX)
            </pre>
            <p class="section-block__text text">
              Метод может принимать один или более аргументов, которые будут добавлены в начало массива.
            </p>
            <p class="section-block__text text">
              Он может быть вызван только для объекта-массива, для которого был вызван.
            </p>
            <p class="section-block__text text">
              Пример использования:
            </p>
            <pre class="section-block__pre pre">
let fruits = ['apple', 'banana', 'orange'];

let newLength = fruits.unshift('pear', 'kiwi');
console.log(newLength); <span class="com">// выводит 5</span>

console.log(fruits); <span class="com">// выводит ['pear', 'kiwi', 'apple', 'banana', 'orange']</span>
            </pre>
            <p class="section-block__text text">
              В этом примере мы создали массив [2, 3], затем вызвали метод <span class="span-text">unshift()</span> для этого массива, передав два элемента (0 и 1) в качестве аргументов.
            </p>
            <p class="section-block__text text">
              Эти элементы были добавлены в начало массива, и метод вернул новую длину массива (4).
            </p>
            <p class="section-block__text text">
              Затем мы вывели новую длину массива и сам массив.
            </p>
          </div>
          <div class="section__block section-block">
            <h3 class="section-block__title title">Метод push()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">push()</span> в JavaScript используется для добавления одного или нескольких элементов в конец массива.
            </p>
            <p class="section-block__text text">
              Он изменяет исходный массив, добавляя новые элементы.
            </p>
            <p class="section-block__text text">
              Синтаксис метода:
            </p>
            <pre class="section-block__pre pre">
array.push(element1, element2, ..., elementN)
            </pre>
            <p class="section-block__text text">
              Параметры: Метод <span class="span-text">push()</span> принимает неограниченное количество параметров, которые являются элементами, добавляемыми в конец массива.
            </p>
            <p class="section-block__text text">
              Пример использования метода:
            </p>
            <pre class="section-block__pre pre">
const array = [1, 2, 3, 4];
array.push(5, 6);
console.log(array); <span class="com">// Выведет [1, 2, 3, 4, 5, 6]</span>
            </pre>
            <p class="section-block__text text">
              В данном примере метод <span class="span-text">push()</span> добавляет элементы 5 и 6 в конец массива array. После выполнения метода массив array становится равен [1, 2, 3, 4, 5, 6].
            </p>
            <p class="section-block__text text">
              Метод <span class="span-text">push()</span> позволяет добавлять элементы в конец массива вместе с расширением его длины. Он полезен, когда вам нужно добавить новые элементы в конец массива, например, при добавлении новых элементов в список или при получении данных из внешнего источника.
            </p>
            <p class="section-block__text text">
              Значение, возвращаемое методом <span class="span-text">push()</span>, является новой длиной массива после добавления элементов.
            </p>
          </div>
        </div>
      </section>
      <section id="splice" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Метод splice()</h2>
          <div class="section__block section-block">
            <p class="section-block__text text">
              Метод <span class="span-text">splice()</span> в JavaScript используется для изменения содержимого массива путем удаления, замены или добавления элементов. Он изменяет исходный массив и возвращает новый массив, содержащий удаленные элементы (если есть).
            </p>
            <p class="section-block__text text">
              Синтаксис метода:
            </p>
            <pre class="section-block__pre pre">
array.splice(start, deleteCount, item1, item2, ...)
            </pre>
            <ul class="section-block__list">
              <li class="section-block__item">
                <span class="span-text">start</span>: Обязательный параметр. Определяет индекс позиции, с которой начинается изменение массива. Если значение отрицательное, то индекс начинается с конца массива, где -1 является последним элементом.
              </li>
              <li class="section-block__item">
                <span class="span-text">deleteCount</span>: Необязательный параметр. Определяет количество элементов, которые будут удалены из массива. Если не указано, будут удалены все элементы после <span class="span-text">start</span>.
              </li>
              <li class="section-block__item">
                <span class="span-text">item1, item2, ...</span>: Необязательные параметры. Элементы, которые будут добавлены в массив, начиная с позиции <span class="span-text">start</span>.
              </li>
            </ul>
            <p class="section-block__text text">
              Примеры использования метода:
            </p>
            <pre class="section-block__pre pre">
const arr = [1,2,3,4,5,6,7,8,9];

const array = arr.splice(3, 2, "pear", 'kiwi', 'apple', 'banana', 'orange');

console.log(arr); <span class="com">// [1,2,3,"pear","kiwi","apple","banana","orange",6,7,8,9]</span>
console.log(array); <span class="com">// [4,5]</span>
            </pre>
            <p class="section-block__text text">Добавление элементов в заданные позиции:</p>
            <pre class="section-block__pre pre">
const fruits = ['apple', 'blackberry', 'blueberry', 'date'];

fruits.splice(2, 0, 'kiwi', 'lemon');
console.log(fruits); <span class="com">// ['apple', 'blackberry', 'kiwi', 'lemon', 'blueberry', 'date']</span>
            </pre>
            <p class="section-block__text text">
              Метод <span class="span-text">splice()</span> является мощным инструментом для манипуляций с массивами в JavaScript. Вы можете использовать его для удаления, замены и добавления элементов в массив, в зависимости от ваших потребностей.
            </p>
          </div>
        </div>
      </section>
      <section id="indexof" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Метод indexOf()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <p class="section-block__text text">
              Функция <span class="span-text">indexOf()</span> в JavaScript
              используется для поиска индекса первого вхождения заданного
              значения в массиве или строки.
            </p>
            <p class="section-block__text text">
              Для <span class="span-text">indexOf()</span> важны три значения:
            </p>
            <p class="section-block__text text">
              - тип данных;
            </p>
            <p class="section-block__text text">
              - регистр в случае со строкой;
            </p>
            <p class="section-block__text text">
              - индекс, с которого начинается поиск. По умолчанию 0.
            </p>
            <p class="section-block__text text">
              В случае строки, функция принимает один аргумент - подстроку,
              которую необходимо найти. Например:
            </p>
            <pre class="section-block__pre pre">
var str = "Hello, World!";
var index = str.indexOf("World");

console.log(index); <span class="com">// 7</span>
    </pre>
            <p class="section-block__text text">
              В данном случае, функция
              <span class="span-text">indexOf()</span> вернет индекс первого
              вхождения подстроки "World" в строку "Hello, World!", равный 7.
            </p>
            <p class="section-block__text text">
              Если подстрока не найдена, функция возвращает -1.
            </p>
            <p class="section-block__text text">
              В случае массива, функция также принимает один аргумент -
              значение элемента, которое нужно найти. Например:
            </p>
            <pre class="section-block__pre pre">
var arr = [1, 2, 3, 4, 5];
var index = arr.indexOf(3);

console.log(index); <span class="com">// 2</span>
    </pre>
            <p class="section-block__text text">
              В данном случае, функция
              <span class="span-text">indexOf()</span> вернет индекс первого
              вхождения значения 3 в массиве [1, 2, 3, 4, 5], равный 2.
            </p>
            <p class="section-block__text text">
              Если значение не найдено, функция возвращает -1.
            </p>
            <p class="section-block__text text">
              Функция <span class="span-text">indexOf()</span> также может
              принимать второй аргумент, который задает индекс, с которого
              нужно начать поиск. Например:
            </p>
            <pre class="section-block__pre pre">
var str = "Hello, World!";
var index = str.indexOf("o", 5);

console.log(index); <span class="com">// 7</span>
    </pre>
            <p class="section-block__text text">
              В данном случае, функция
              <span class="span-text">indexOf()</span> ищет первое вхождение
              буквы "o" в строке "Hello, World!", начиная с позиции с индексом
              5.
            </p>
          </div>
        </div>
      </section>
      <section id="split" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Методы split() и join()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title">split()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">split()</span> в JavaScript используется для разделения строки на подстроки с помощью указанного разделителя и возвращает массив с этими подстроками.
            </p>
            <ul class="section-block__list">
              <p class="section-block__text text">
                Синтаксис метода <span class="span-text">split()</span> выглядит следующим образом: <span class="span-text">строка.split(разделитель, ограничение)</span>
              </p>
              <li class="section-block__item">
                <strong>Строка:</strong> Это исходная строка, которую вы хотите разделить на подстроки
              </li>
              <li class="section-block__item">
                <strong>Разделитель:</strong> Это строка или регулярное выражение, по которому будет осуществляться разделение строки. Если разделитель опущен, то строка будет разделена на массив символов.
              </li>
              <li class="section-block__item">
                <strong>Ограничение (необязательный параметр):</strong> Максимальное количество разделений, которые нужно выполнить. Если этот параметр указан, то метод будет разделять строку только до указанного количества разделений.
              </li>
            </ul>
            <p class="section-block__text text">
              Примеры разных вариантов:
            </p>
            <pre class="section-block__pre pre">
const splitStr = 'Hello! World!';

const a = splitStr.split(); <span class="com">// ["Hello! World!"]</span>

const a = splitStr.split(''); <span class="com">// ["H","e","l","l","o","!"," ","W","o","r","l","d","!"]</span>

const a = splitStr.split(' '); <span class="com">// ["Hello!","World!"]</span>

const a = splitStr.split('!'); <span class="com">// ["Hello"," World",""]</span>

const a = splitStr.split('! '); <span class="com">// ["Hello","World!"]</span>

console.log(a);
            </pre>
            <ol class="section-block__list section-block__list--numbs">
              <p class="section-block__text text">
                Подробные примеры использования метода <span class="span-text">split()</span>:
              </p>
              <li class="section-block__item">
                <p class="section-block__text text">
                  Разделение строки на подстроки с помощью пробела как разделителя:
                </p>
                <pre class="section-block__pre pre">
let str = 'Hello world!';
let arr = str.split(' ');

console.log(arr); <span class="com">// ['Hello','world!']</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  Разделение строки на подстроки с помощью запятой как разделителя и указанием ограничения:
                </p>
                <pre class="section-block__pre pre">
let str = 'apple,banana,grape';
let arr = str.split(',', 2);

console.log(arr); <span class="com">// ['apple','banana']</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  Разделение строки на массив символов без указания разделителя:
                </p>
                <pre class="section-block__pre pre">
let str = 'Hello';
let arr = str.split('');

console.log(arr); <span class="com">// ['H','e','l','l','o']</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  Разделение строки на подстроки с использованием регулярного выражения:
                </p>
                <pre class="section-block__pre pre">
let str = 'Hello, world!';
let arr = str.split(/[, ]+/);

console.log(arr); <span class="com">// ['Hello', 'world!']</span>
                </pre>
              </li>
            </ol>
            <p class="section-block__text text">
              Метод <span class="span-text">split()</span> является полезным инструментом при работе с текстовыми данными в JavaScript и позволяет легко разделять строки на подстроки для дальнейшей обработки.
            </p>
          </div>
          <div class="section__block section-block">
            <h3 class="section-block__title title">join()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">join()</span> в JavaScript используется для объединения всех элементов массива в одну строку.
            </p>
            <p class="section-block__text text">
              Он принимает один необязательный параметр - строку-разделитель, которая будет вставлена между элементами массива при объединении.
            </p>
            <p class="section-block__text text">
              Синтаксис метода <span class="span-text">join()</span> выглядит следующим образом: <span class="span-text">array.join(separator)</span>
            </p>
            <ul class="section-block__list">
              <p class="section-block__text text">где:</p>
              <li class="section-block__item">
                <strong>array</strong> - массив, элементы которого нужно объединить;
              </li>
              <li class="section-block__item">
                <strong>separator (необязательный)</strong> - строка, которая будет использована в качестве разделителя между элементами массива. Если этот параметр не указан, то по умолчанию используется запятая.
              </li>
            </ul>
            <p class="section-block__text text">Примеры использования метода join():</p>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item">
                <p class="section-block__text text">
                  Объединение элементов массива с использованием запятой в качестве разделителя:
                </p>
                <pre class="section-block__pre pre">
var fruits = ["apple", "banana", "orange"];
var result = fruits.join();
console.log(result); <span class="com">// "apple,banana,orange"</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  Объединение элементов массива с использованием пробела в качестве разделителя:
                </p>
                <pre class="section-block__pre pre">
var numbers = [1, 2, 3, 4, 5];
var result = numbers.join(" ");
console.log(result); <span class="com">// "1 2 3 4 5"</span>
                </pre>
              </li>
              <li class="section-block__item">
                <p class="section-block__text text">
                  Объединение элементов массива без разделителя:
                </p>
                <pre class="section-block__pre pre">
var letters = ["a", "b", "c", "d"];
var result = letters.join("");
console.log(result); <span class="com">// "abcd"</span>
                </pre>
              </li>
            </ol>
            <p class="section-block__text text">
              Метод <span class="span-text">join()</span> полезен при необходимости конвертировать массив в строку или создать CSV-файл.
            </p>
            <p class="section-block__text text">
              Он также может быть использован с методом <span class="span-text">split()</span> для разбиения строки на массив элементов.
            </p>
          </div>
        </div>
      </section>
      <section id="map" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Метод map()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <p class="section-block__text text">
              Метод <span class="span-text">map()</span> в&nbsp;JavaScript&nbsp;&mdash; это метод массива, который принимает в&nbsp;качестве аргументов функцию обратного вызова (callback) и&nbsp;используется для преобразования каждого элемента массива.
            </p>
            <p class="section-block__text text">Синтаксис:</p>
            <pre class="section-block__pre pre">
array.map(callback(currentValue, index, arr), thisArg)
            </pre>
            <ul class="section-block__list">
              <li class="section-block__item">
                <span class="span-text">callback</span> - функция, которая будет вызвана для каждого элемента массива. Она принимает три аргумента: <span class="span-text">currentValue</span>, <span class="span-text">index</span> и <span class="span-text">array</span>;
              </li>
              <li class="section-block__item">
                <span class="span-text">currentValue</span> - текущий обрабатываемый элемент массива;
              </li>
              <li class="section-block__item">
                <span class="span-text">index</span> - индекс текущего элемента;
              </li>
              <li class="section-block__item">
                <span class="span-text">arr</span> - индекс текущего элемента;
              </li>
              <li class="section-block__item">
                <span class="span-text">thisArg (необязательный)</span> - значение, используемое в качестве `this` внутри функции callback.
              </li>
            </ul>
            <pre class="section-block__pre pre">
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let b = a.map((currentValue, index, array) =&gt; {
  return (currentValue * 2 - 1) * 3;
});

console.log(b); <span class="com">// [3,9,15,21,27,33,39,45,51]</span>
            </pre>
            <pre class="section-block__pre pre">
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let c = a.map((currentValue, index, array) =&gt; {
  return (currentValue += 1);
});

console.log(c); <span class="com">// [2,3,4,5,6,7,8,9,10]</span>
            </pre>
            <pre class="section-block__pre pre">
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let d = a.map((currentValue, index, array) =&gt; {
  console.log(index); <span class="com">// 0 1 2 3 4 5 6 7 8</span>
  return currentValue;
});
            </pre>
            <pre class="section-block__pre pre">
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let e = a.map((currentValue, index, array) =&gt; {
  console.log(array); <span class="com">// [1,2,3,4,5,6,7,8,9] - возвращается столько раз, сколько элементов в массиве</span>
  return currentValue;
});
            </pre>
            <pre class="section-block__pre pre">
let a = [1, 2, 3, 4, 5, 6, 7, 8, 9];

let f = [...a];

f[11] = 28;

f.push(34);

delete f[11];

let j = f.map((currentValue, index, array) =&gt; {
  return (currentValue * 2 - 1) * 3;
});

console.log(j); <span class="com">// [3,9,15,21,27,33,39,45,51,,,,201]</span>
            </pre>
            <pre class="section-block__pre pre">
const students = [
  { name: "Василий", age: 18 },
  { name: "Геннадий", age: 23 },
  { name: "Андрей", age: 17 },
  { name: "Тимофей", age: 29 },
  { name: "Иннокентий", age: 17 }
];

console.log(students.map((student) =&gt; {
  return student.name;
})); <span class="com">// ["Василий", "Геннадий", "Андрей", "Тимофей", "Иннокентий"]</span>
            </pre>
            <p class="section-block__text text">
              Метод <span class="span-text">map()</span> создает новый массив с результатом выполнения функции callback для каждого элемента из исходного массива.
            </p>
            <p class="section-block__text text">
              Новый массив будет иметь ту же длину, что и исходный массив, но каждый элемент будет изменен согласно результату функции callback.
            </p>
          </div>
        </div>
      </section>
      <section id="flat" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">Методы flat() и flatMap()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title">flat()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">flat()</span> - это встроенный метод массивов в JavaScript, который используется для "разглаживания" (или "сплющивания") вложенных подмассивов в одну плоскую структуру.
            </p>
            <p class="section-block__text text">
              Когда применяется метод <span class="span-text">flat()</span>, все элементы вложенных подмассивов извлекаются и помещаются в новый массив на одном уровне.
            </p>
            <p class="section-block__text text">
              Метод <span class="span-text">flat()</span> может принимать необязательный аргумент <span class="span-text">depth</span> в виде числового значения, который указывает, на сколько уровней вложенности нужно разгладить. Если <span class="span-text">depth</span> не указан, то метод <span class="span-text">flat()</span> применяется только к одному уровню.
            </p>
            <pre class="section-block__pre pre">
const nestedArray = [1, [2, 3], [4, [5, 6]]];

const flattened = nestedArray.flat(Infinity);

console.log(flattened); <span class="com">// [1, 2, 3, 4, 5, 6]</span>
            </pre>
          </div>
          <div class="section__block section-block">
            <h3 class="section-block__title title">flatMap()</h3>
            <p class="section-block__text text">
                Метод <span class="span-text">flatMap()</span> - это функция высшего порядка в JavaScript, которая применяет функцию к каждому элементу в массиве и затем сглаживает (объединяет) полученные результаты в один массив.
            </p>
            <p class="section-block__text text">
              Синтаксис метода <span class="span-text">flatMap()</span>:
            </p>
            <pre class="section-block__pre pre">
array.flatMap(callback(currentValue, index, array), thisArg)
            </pre>
             <ul class="section-block__list">
              <li class="section-block__item">
                <span class="span-text">array</span> - это исходный массив.
              </li>
              <li class="section-block__item">
                <span class="span-text">callback</span> - это функция, которая будет применена к каждому элементу массива. Она принимает три аргумента: <span class="span-text">currentValue</span> (текущий элемент массива), <span class="span-text">index</span> (индекс текущего элемента) и <span class="span-text">array</span> (исходный массив).
              </li>
              <li class="section-block__item">
                <span class="span-text">thisArg</span> (необязательно) - это значение, которое будет использовано в качестве <span class="span-text">this</span> внутри функции <span class="span-text">callback</span>.
              </li>
              <li class="section-block__item"></li>
            </ul>
            <p class="section-block__text text">
              Метод <span class="span-text">flatMap()</span> применяет функцию <span class="span-text">callback</span> к каждому элементу массива и сохраняет каждый возвращаемый результат в новом массиве. Затем он объединяет все элементы этого нового массива в один. Это отличает <span class="span-text">flatMap()</span> от метода <span class="span-text">m-ap()</span>, который возвращает новый массив с результатами применения функции к каждому элементу, но не объединяет их.
            </p>
            <pre class="section-block__pre pre">
const arr = [1, 2, 3];

<span class="com">// первый вариант</span>
const result = arr.flatMap((num) => {
  return [num, num * 2];
});

console.log("result:", result); <span class="com">// [1,2,2,4,3,6]</span>

<span class="com">// второй вариант</span>
const mappedArr = arr.flatMap(x => [x * 2]);

console.log(mappedArr); <span class="com">// [2, 4, 6]</span>
            </pre>
          </div>
        </div>
      </section>
      <section id="#reduce" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">Методы reduce() и reduceRight()</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title">reduce()</h3>
            <p class="section-block__text text">
              Метод <span class="span-text">reduce()</span> - это метод массивов в JavaScript, который применяет функцию-аккумулятор к каждому элементу массива и возвращает одно значение, которое является результатом аккумуляции.
            </p>
            <p class="section-block__text text">Синтаксис метода:</p>
            <pre class="section-block__pre pre">
array.reduce(callback[, initialValue])
            </pre>
            <ul class="section-block__list">
              <li class="section-block__item">
                <span class="span-text">callback</span> - функция, которая принимает четыре параметра:
              </li>
              <li class="section-block__item">
                <span class="span-text">accumulator</span> - аккумулятор, значение, накапливающее результат;
              </li>
              <li class="section-block__item">
                <span class="span-text">currentValue</span> - текущий обрабатываемый элемент массива;
              </li>
              <li class="section-block__item">
                <span class="span-text">currentIndex</span> - индекс текущего обрабатываемого элемента массива;
              </li>
              <li class="section-block__item">
                <span class="span-text">array</span> - сам массив, к которому применяется метод reduce.
              </li>
              <li class="section-block__item">
                <span class="span-text">initialValue</span> (необязательный) - начальное значение аккумулятора. Если это значение не указано, то аккумулятор будет равен первому элементу массива, а итерация начнется со второго элемента.
              </li>
            </ul>
            <p class="section-block__text text">
              Пример использования метода:
            </p>
            <pre class="section-block__pre pre">
const numbers = [1, 2, 3, 4, 5];

<span class="com">// Сумма элементов массива</span>
const sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue);

console.log(sum); <span class="com">// Выведет: 15</span>

<span class="com">// Умножение элементов массива</span>
const product = numbers.reduce((accumulator, currentValue) => accumulator * currentValue);

console.log(product); <span class="com">// Выведет: 120</span>
            </pre>
            <p class="section-block__text text">
              В приведенном примере производится суммирование и умножение элементов массива при помощи метода reduce. В первом случае аккумулятор инициализируется значением 1 и при каждой итерации к нему добавляется текущий элемент массива. В результате получаем сумму всех элементов. Во втором случае аккумулятор инициализируется значением 1 и при каждой итерации умножается на текущий элемент массива. Таким образом, получаем произведение всех элементов.
            </p>
            <pre class="section-block__pre pre"></pre>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ol>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre"></pre>
          </div>
        </div>
      </section>
      <section id="#" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">CAPTION</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <ul class="section-block__list">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ul>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ol>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre"></pre>
          </div>
        </div>
      </section>
      <section id="#" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">CAPTION</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <ul class="section-block__list">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ul>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ol>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre"></pre>
          </div>
        </div>
      </section>
      <!-- <section id="#" class="section hidden">
        <div class="section__container">
          <h2 class="section__title title">CAPTION</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <ul class="section-block__list">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ul>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ol>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre"></pre>
          </div>
        </div>
      </section>
      <section id="#" class="section hidden dark-page">
        <div class="section__container">
          <h2 class="section__title title">CAPTION</h2>
          <div class="section__block section-block">
            <h3 class="section-block__title title"></h3>
            <ul class="section-block__list">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ul>
            <ol class="section-block__list section-block__list--numbs">
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
              <li class="section-block__item"></li>
            </ol>
            <p class="section-block__text text"></p>
            <pre class="section-block__pre pre"></pre>
          </div>
        </div>
      </section> -->
    </main>
    <footer id="footer" class="footer">
      <div class="footer__container">
        FOOTER
      </div>
    </footer>
  </div>
</body>

</html>